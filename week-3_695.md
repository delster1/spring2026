---
tags:
    - eecs695
    - spring26
date:
    - 2026-02-02
---

# Week 3 - 2/2 - 2/6

## Lec 1 - Intro to Linux CLI - 02/02

SigKill - 9 always kills process
SigTerm - 15 - kills processes but we can register a signal handler to signal 15

**pipelines** 
- send output / input from processes to processes

## Lec 2 - Intro x86 - Missed - 02/04

## Lec 3 - x86 Cont'd - 02/06

x86
- can perform math directly on memory - don't need to load everything into registers

**indirect addressing modes** 
- used to specify a memory address by doing some computation

format:
- base + index * scale + displacement
- base and index are 65-bit registers
- scale is int from 1,2,4,8[]
- displacement is 32-bit int constant

EX:
```x86
movq %eax, DWORD PTR 172[%rax, rdx, 8]
```
- loads value at address \[%rax + %rdx*8 + 172]

### x86-64 General Purpose Integer registers
- GPRs - registters generally avaialble to user code 
- can be used interchangeably for many operations

### Special registers
instruction pointer `rip` or `eip`
- addr of next instruction

flags register `rflags`
- used for comparisons, conditional branches, properties of arithmetic ops

segment registers
- used when segmentation was popular in memory 

constrol registers `cr0-cr10` and debug registers `dr0-dr7`
- control CPU mode, provide hardware support for debugging 

floating point & vector registers- a whole bunch

### Common instructions 

**arithmetic** 
`add dst, src`          dst += src
`sub dst, src`          dst -= src
`inc dst`               dst += 1
`dec dst`               dec -= 1
`neg dst`               dst = -dst
`cmp src1, src2`        set status flags based on src1 - src2
`and dst, src`          dst &= src
`or dst, src`           dst |= src
`xor dst`               dst ^= 1
`not dst`               dec != 1
`test dst`              set status flags based on src1 & src2

**random important instructions** 
`lea dst, src` - load memory addres into dst (dst = &src)
`nop`          - no op

- lots more! 
